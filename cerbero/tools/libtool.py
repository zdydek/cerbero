#!/usr/bin/env python
# cerbero - a multi-platform build system for Open Source software
# Copyright (C) 2012 Andoni Morales Alastruey <ylatuya@gmail.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

import re
import os
from cerbero.config import Platform
from cerbero.build.filesprovider import find_shlib_regex, FilesProvider
from cerbero.errors import FatalError

class LibtoolLibrary(object):
    '''
    Helper class to create libtool libraries files (.la)
    '''

    LIBTOOL_TPL = '''\
# %(laname)s - a libtool library file
# Generated by libtool (GNU libtool) 2.4.2 Debian-2.4.2-1ubuntu1
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# The name that we can dlopen(3).
dlname='%(dlname)s'

# Names of this library.
library_names='%(library_names)s'

# The name of the static archive.
old_library='%(old_library)s'

# Linker flags that can not go in dependency_libs.
inherited_linker_flags=''

# Libraries that this one depends upon.
dependency_libs='%(dependency_libs)s'

# Names of additional weak libraries provided by this library
weak_library_names=''

# Version information for %(libname)s.
current=%(current)s
age=%(age)s
revision=%(revision)s

# Is this an already installed library?
installed=yes

# Should we warn about portability when linking against -modules?
shouldnotlink=no

# Files to dlopen/dlpreopen
dlopen=''
dlpreopen=''

# Directory that this library needs to be installed in:
libdir='%(libdir)s'
'''

    def __init__(self, libname, libdir, platform, deps=None):
        self.libtool_vars = {
            'libname': '',
            'laname': '',
            'dlname': '',
            'library_names': '',
            'old_library': '',
            'dependency_libs': '',
            'current': '',
            'age': '',
            'revision': '',
            'libdir': ''}

        if deps is None:
            deps = ''
        self.libname = libname
        self.libdir = libdir
        self.laname = 'lib{}.la'.format(libname)

        regex = FilesProvider.EXTENSIONS[platform]['sregex']
        regex = regex.format(re.escape(self.libname))
        # Find shared libraries
        shlibs = self._find_shlibs(regex, platform)
        # libfoo.so.2 or libfoo.so (if no versioning at all)
        try:
            dlname = shlibs[-2] or shlibs[-1]
        except IndexError:
            # No shared library was installed by the recipe
            dlname = ''
        # Auto-detect major/minor/micro versions
        major, minor, micro = self._autodetect_versions(regex, shlibs)
        old_library = 'lib{}.a'.format(libname)
        self.change_value('laname', self.laname)
        self.change_value('libname', 'lib' + self.libname)
        self.change_value('dlname', dlname)
        self.change_value('library_names', ' '.join(shlibs))
        self.change_value('old_library', old_library)
        self.change_value('current', minor)
        self.change_value('age', minor)
        self.change_value('revision', micro)
        self.change_value('libdir', libdir)
        self.change_value('dependency_libs', self._parse_deps(deps))

    def _find_shlibs(self, regex, platform):
        if self.libdir.endswith('/'):
            self.libdir = self.libdir[:-1]
        prefix = os.path.dirname(self.libdir)
        libdir = os.path.basename(self.libdir)
        ext = FilesProvider.EXTENSIONS[platform]['srext']
        libs = find_shlib_regex(self.libname, prefix, libdir, ext, regex)
        # Return in order from most version components to least. F.ex:
        # ['libfoo.so.2.4800.1', 'libfoo.so.2', 'libfoo.so']
        return sorted([os.path.basename(lib) for lib in libs], reverse=True)

    def _autodetect_versions(self, regex, libs):
        "Auto-detect major/minor/micro versions"
        if not libs:
            return [''] * 3
        # Find the library with the most version components
        # So if we have:
        #  ['lib/libfoo.so.0.11.0', 'lib/libfoo.so', 'lib/libfoo.so.0']
        # This will yield
        #  'libfoo.so.0.11.0'
        # Usually, this is the actual library and the rest are symlinks
        actual_lib = os.path.basename(sorted(libs, reverse=True)[0])
        # Get the version components. This would yield:
        # ('0', '11', '0')
        # For libfoo.2.6, this will yield:
        # ('2', '6', '')
        return [v[1:] if v else '' for v in re.match(regex, actual_lib).groups()]

    def save(self):
        path = os.path.join(self.libdir, self.laname)
        with open(path, 'w') as f:
            f.write(self.LIBTOOL_TPL % self.libtool_vars)

    def change_value(self, key, val):
        self.libtool_vars[key] = val

    def _parse_deps(self, deps):
        deps_str = ''
        libtool_deps = [x for x in deps if not x.startswith('-l')]
        lib_deps = [x for x in deps if x.startswith('-l')]
        for d in libtool_deps:
            if not d.startswith('lib'):
                d = 'lib' + d
            deps_str += ' %s/%s.la ' % (self.libdir, d)
        deps_str += ' '.join(lib_deps)
        return deps_str
